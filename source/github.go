package source

import (
    "encoding/json"
    "errors"
    "io/ioutil"
    "net/http"
)

type Repositories struct {
    Total_count        int                `json:"total_count"`
    Incomplete_results bool               `json:"incomplete_results"`
    Items              []RepositoriesItem `json:"items"`
}

type RepositoriesItem struct {
    Id          int    `json:"id"`
    Name        string `json:"name"`
    Full_name   string `json:"full_name"`
    Description string `json:"description"`
    Svn_url     string `json:"svn_url"`
}

type GitHubSource struct {
    TotalCount int
    HasNewMsg  bool
    NewMsg     RepositoriesItem
    Api_url    string
}

var (
    ErrDataPull    = errors.New("Data pull error, waiting for the next cycle")
    ErrDataParsing = errors.New("Data parsing error, waiting for the next cycle")
    ErrDataEmpty   = errors.New("Data is empty, waiting for the next cycle")
)

func (gs *GitHubSource) Refresh() error {
    var Repo Repositories
    resp, err := http.Get(gs.Api_url)
    if err != nil {
        return ErrDataPull
    }

    defer resp.Body.Close()

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return ErrDataPull
    }
    if err := json.Unmarshal([]byte(body), &Repo); err == nil {
        if Repo.Total_count == 0 {
            return ErrDataEmpty
        }
        if gs.TotalCount == 0 {
            gs.TotalCount = Repo.Total_count
        } else if gs.TotalCount != Repo.Total_count && gs.TotalCount > Repo.Total_count {
            latest := Repo.Items[0]
            gs.TotalCount = Repo.Total_count
            gs.HasNewMsg = true
            gs.NewMsg = latest
        }
    } else {
        return ErrDataParsing
    }
    return nil
}

func (gs *GitHubSource) CheckNewMsg() (has bool) {
    return gs.HasNewMsg
}

func (gs *GitHubSource) SetHasNewMsg(flag bool) {
    gs.HasNewMsg = flag
}

func (gs *GitHubSource) GetNewMsg() (Msg RepositoriesItem) {
    return gs.NewMsg
}
